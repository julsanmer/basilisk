<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="avs_eigen_support_8cpp" kind="file" language="C++">
    <compoundname>avsEigenSupport.cpp</compoundname>
    <includes local="no">iostream</includes>
    <includes local="no">math.h</includes>
    <includes refid="avs_eigen_support_8h" local="yes">avsEigenSupport.h</includes>
    <includes refid="rigid_body_kinematics_8h" local="yes">rigidBodyKinematics.h</includes>
    <includes refid="macro_definitions_8h" local="yes">architecture/utilities/macroDefinitions.h</includes>
    <incdepgraph>
      <node id="6">
        <label>avsEigenMRP.h</label>
        <link refid="avs_eigen_m_r_p_8h_source"/>
      </node>
      <node id="1">
        <label>/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp</label>
        <link refid="avs_eigen_support_8cpp"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
      </node>
      <node id="4">
        <label>avsEigenSupport.h</label>
        <link refid="avs_eigen_support_8h_source"/>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
      </node>
      <node id="8">
        <label>architecture/utilities/bskLogging.h</label>
        <link refid="bsk_logging_8h_source"/>
      </node>
      <node id="9">
        <label>architecture/utilities/macroDefinitions.h</label>
        <link refid="macro_definitions_8h_source"/>
      </node>
      <node id="7">
        <label>rigidBodyKinematics.h</label>
        <link refid="rigid_body_kinematics_8h_source"/>
        <childnode refid="8" relation="include">
        </childnode>
      </node>
      <node id="5">
        <label>Eigen/Dense</label>
      </node>
      <node id="2">
        <label>iostream</label>
      </node>
      <node id="3">
        <label>math.h</label>
      </node>
    </incdepgraph>
    <sectiondef kind="func">
      <memberdef kind="function" id="avs_eigen_support_8cpp_1a5b0bfa223918c75d0d39346e5e08d1e8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eigenMatrixXd2CArray</definition>
        <argsstring>(Eigen::MatrixXd inMat, double *outArray)</argsstring>
        <name>eigenMatrixXd2CArray</name>
        <param>
          <type>Eigen::MatrixXd</type>
          <declname>inMat</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>outArray</declname>
        </param>
        <briefdescription>
<para>General conversion between any Eigen matrix and output array. </para>
        </briefdescription>
        <detaileddescription>
<para>This function provides a general conversion between an Eigen matrix and an output C array. Note that this routine would convert an inbound type to a MatrixXd and then transpose the matrix which would be inefficient in a lot of cases. <simplesect kind="return"><para>void </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>inMat</parametername>
</parameternamelist>
<parameterdescription>
<para>The source Eigen matrix that we are converting </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>outArray</parametername>
</parameternamelist>
<parameterdescription>
<para>The destination array (sized by the user!) we copy into </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" line="40" column="6" bodyfile="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" bodystart="40" bodyend="44"/>
      </memberdef>
      <memberdef kind="function" id="avs_eigen_support_8cpp_1a8f49e5b32d703df9e644b53884be532a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eigenMatrixXi2CArray</definition>
        <argsstring>(Eigen::MatrixXi inMat, int *outArray)</argsstring>
        <name>eigenMatrixXi2CArray</name>
        <param>
          <type>Eigen::MatrixXi</type>
          <declname>inMat</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>outArray</declname>
        </param>
        <briefdescription>
<para>General conversion between any Eigen matrix and output array. </para>
        </briefdescription>
        <detaileddescription>
<para>This function provides a general conversion between an Eigen matrix and an output C array. Note that this routine would convert an inbound type to a MatrixXd and then transpose the matrix which would be inefficient in a lot of cases. <simplesect kind="return"><para>void </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>inMat</parametername>
</parameternamelist>
<parameterdescription>
<para>The source Eigen matrix that we are converting </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>outArray</parametername>
</parameternamelist>
<parameterdescription>
<para>The destination array (sized by the user!) we copy into </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" line="54" column="6" bodyfile="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" bodystart="54" bodyend="58"/>
      </memberdef>
      <memberdef kind="function" id="avs_eigen_support_8cpp_1a794c4abb778e3a203ca08dfb3f707050" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eigenVector3d2CArray</definition>
        <argsstring>(Eigen::Vector3d &amp;inMat, double *outArray)</argsstring>
        <name>eigenVector3d2CArray</name>
        <param>
          <type>Eigen::Vector3d &amp;</type>
          <declname>inMat</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>outArray</declname>
        </param>
        <briefdescription>
<para>Rapid conversion between 3-vector and output array. </para>
        </briefdescription>
        <detaileddescription>
<para>This function provides a direct conversion between a 3-vector and an output C array. We are providing this function to save on the inline conversion and the transpose that would have been performed by the general case. <simplesect kind="return"><para>void </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>inMat</parametername>
</parameternamelist>
<parameterdescription>
<para>The source Eigen matrix that we are converting </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>outArray</parametername>
</parameternamelist>
<parameterdescription>
<para>The destination array we copy into </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" line="67" column="6" bodyfile="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" bodystart="67" bodyend="70"/>
      </memberdef>
      <memberdef kind="function" id="avs_eigen_support_8cpp_1a1f1b705018c04b0a2e22d7b92453bff0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eigenMRPd2CArray</definition>
        <argsstring>(Eigen::Vector3d &amp;inMat, double *outArray)</argsstring>
        <name>eigenMRPd2CArray</name>
        <param>
          <type>Eigen::Vector3d &amp;</type>
          <declname>inMat</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>outArray</declname>
        </param>
        <briefdescription>
<para>Rapid conversion between MRP and output array. </para>
        </briefdescription>
        <detaileddescription>
<para>This function provides a direct conversion between an MRP and an output C array. We are providing this function to save on the inline conversion and the transpose that would have been performed by the general case. <simplesect kind="return"><para>void </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>inMat</parametername>
</parameternamelist>
<parameterdescription>
<para>The source Eigen MRP that we are converting </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>outArray</parametername>
</parameternamelist>
<parameterdescription>
<para>The destination array we copy into </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" line="79" column="6" bodyfile="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" bodystart="79" bodyend="82"/>
      </memberdef>
      <memberdef kind="function" id="avs_eigen_support_8cpp_1a1d53f0520c190b8992c5a6f51d70dc48" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eigenMatrix3d2CArray</definition>
        <argsstring>(Eigen::Matrix3d &amp;inMat, double *outArray)</argsstring>
        <name>eigenMatrix3d2CArray</name>
        <param>
          <type>Eigen::Matrix3d &amp;</type>
          <declname>inMat</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>outArray</declname>
        </param>
        <briefdescription>
<para>Rapid conversion between 3x3 matrix and output array. </para>
        </briefdescription>
        <detaileddescription>
<para>This function provides a direct conversion between a 3x3 matrix and an output C array. We are providing this function to save on the inline conversion that would have been performed by the general case. <simplesect kind="return"><para>void </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>inMat</parametername>
</parameternamelist>
<parameterdescription>
<para>The source Eigen matrix that we are converting </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>outArray</parametername>
</parameternamelist>
<parameterdescription>
<para>The destination array we copy into </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" line="91" column="6" bodyfile="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" bodystart="91" bodyend="95"/>
      </memberdef>
      <memberdef kind="function" id="avs_eigen_support_8cpp_1ad581c3de327ceeec7e335d2b533d9924" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Eigen::MatrixXd</type>
        <definition>Eigen::MatrixXd cArray2EigenMatrixXd</definition>
        <argsstring>(double *inArray, int nRows, int nCols)</argsstring>
        <name>cArray2EigenMatrixXd</name>
        <param>
          <type>double *</type>
          <declname>inArray</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nRows</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nCols</declname>
        </param>
        <briefdescription>
<para>General conversion between a C array and an Eigen matrix. </para>
        </briefdescription>
        <detaileddescription>
<para>This function performs the general conversion between an input C array and an Eigen matrix. Note that to use this function the user MUST size the Eigen matrix ahead of time so that the internal map call has enough information to ingest the C array. <simplesect kind="return"><para>Eigen::MatrixXd </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>inArray</parametername>
</parameternamelist>
<parameterdescription>
<para>The input array (row-major) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nRows</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nCols</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" line="106" column="17" bodyfile="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" bodystart="106" bodyend="112"/>
      </memberdef>
      <memberdef kind="function" id="avs_eigen_support_8cpp_1ab52f82916ad902d15fa21d91075e0529" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Eigen::Vector3d</type>
        <definition>Eigen::Vector3d cArray2EigenVector3d</definition>
        <argsstring>(double *inArray)</argsstring>
        <name>cArray2EigenVector3d</name>
        <param>
          <type>double *</type>
          <declname>inArray</declname>
        </param>
        <briefdescription>
<para>Specific conversion between a C array and an Eigen 3-vector. </para>
        </briefdescription>
        <detaileddescription>
<para>This function performs the conversion between an input C array 3-vector and an output Eigen vector3d. This function is provided in order to save an unnecessary conversion between types. <simplesect kind="return"><para>Eigen::Vector3d </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>inArray</parametername>
</parameternamelist>
<parameterdescription>
<para>The input array (row-major) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" line="120" column="17" bodyfile="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" bodystart="120" bodyend="123"/>
      </memberdef>
      <memberdef kind="function" id="avs_eigen_support_8cpp_1ac416faaf51adbb7f60a9ec0472d413c6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Eigen::MRPd</type>
        <definition>Eigen::MRPd cArray2EigenMRPd</definition>
        <argsstring>(double *inArray)</argsstring>
        <name>cArray2EigenMRPd</name>
        <param>
          <type>double *</type>
          <declname>inArray</declname>
        </param>
        <briefdescription>
<para>Specific conversion between a C array and an Eigen MRPs. </para>
        </briefdescription>
        <detaileddescription>
<para>This function performs the conversion between an input C array 3-vector and an output Eigen MRPd. This function is provided in order to save an unnecessary conversion between types. <simplesect kind="return"><para>Eigen::MRPd </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>inArray</parametername>
</parameternamelist>
<parameterdescription>
<para>The input array (row-major) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" line="131" column="13" bodyfile="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" bodystart="131" bodyend="137"/>
      </memberdef>
      <memberdef kind="function" id="avs_eigen_support_8cpp_1a1355ee7d1ee3da4daa7d40a8ff051335" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Eigen::Matrix3d</type>
        <definition>Eigen::Matrix3d cArray2EigenMatrix3d</definition>
        <argsstring>(double *inArray)</argsstring>
        <name>cArray2EigenMatrix3d</name>
        <param>
          <type>double *</type>
          <declname>inArray</declname>
        </param>
        <briefdescription>
<para>Specfici conversion between a C array and an Eigen 3x3 matrix. </para>
        </briefdescription>
        <detaileddescription>
<para>This function performs the conversion between an input C array 3x3-matrix and an output Eigen vector3d. This function is provided in order to save an unnecessary conversion between types. <simplesect kind="return"><para>Eigen::Matrix3d </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>inArray</parametername>
</parameternamelist>
<parameterdescription>
<para>The input array (row-major) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" line="145" column="17" bodyfile="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" bodystart="145" bodyend="148"/>
      </memberdef>
      <memberdef kind="function" id="avs_eigen_support_8cpp_1ad9561e31f68baf51c2fef3a5d3f45dbf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Eigen::Matrix3d</type>
        <definition>Eigen::Matrix3d c2DArray2EigenMatrix3d</definition>
        <argsstring>(double in2DArray[3][3])</argsstring>
        <name>c2DArray2EigenMatrix3d</name>
        <param>
          <type>double</type>
          <declname>in2DArray</declname>
          <array>[3][3]</array>
        </param>
        <briefdescription>
<para>Specfici conversion between a C 2D array and an Eigen 3x3 matrix. </para>
        </briefdescription>
        <detaileddescription>
<para>This function performs the conversion between an input C 3x3 2D-array and an output Eigen vector3d. This function is provided in order to save an unnecessary conversion between types <simplesect kind="return"><para>Eigen::Matrix3d </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>in2DArray</parametername>
</parameternamelist>
<parameterdescription>
<para>The input 2D-array </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" line="156" column="17" bodyfile="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" bodystart="156" bodyend="166"/>
      </memberdef>
      <memberdef kind="function" id="avs_eigen_support_8cpp_1adecdac8430ea564b6ce195ddf6a92461" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Eigen::Matrix3d</type>
        <definition>Eigen::Matrix3d eigenM1</definition>
        <argsstring>(double angle)</argsstring>
        <name>eigenM1</name>
        <param>
          <type>double</type>
          <declname>angle</declname>
        </param>
        <briefdescription>
<para>returns the first axis DCM with the input angle </para>
        </briefdescription>
        <detaileddescription>
<para>This function returns the Eigen DCM that corresponds to a 1-axis rotation by the angle theta. The DCM is the positive theta rotation from the original frame to the final frame. <simplesect kind="return"><para>Eigen::Matrix3d </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>angle</parametername>
</parameternamelist>
<parameterdescription>
<para>The input rotation angle </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" line="174" column="17" bodyfile="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" bodystart="174" bodyend="186"/>
      </memberdef>
      <memberdef kind="function" id="avs_eigen_support_8cpp_1a6d9818b693306dae8037c1b25340a68b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Eigen::Matrix3d</type>
        <definition>Eigen::Matrix3d eigenM2</definition>
        <argsstring>(double angle)</argsstring>
        <name>eigenM2</name>
        <param>
          <type>double</type>
          <declname>angle</declname>
        </param>
        <briefdescription>
<para>returns the second axis DCM with the input angle </para>
        </briefdescription>
        <detaileddescription>
<para>This function returns the Eigen DCM that corresponds to a 2-axis rotation by the angle theta. The DCM is the positive theta rotation from the original frame to the final frame. <simplesect kind="return"><para>Eigen::Matrix3d </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>angle</parametername>
</parameternamelist>
<parameterdescription>
<para>The input rotation angle </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" line="194" column="17" bodyfile="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" bodystart="194" bodyend="206"/>
      </memberdef>
      <memberdef kind="function" id="avs_eigen_support_8cpp_1acad044291638543549211465aca44769" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Eigen::Matrix3d</type>
        <definition>Eigen::Matrix3d eigenM3</definition>
        <argsstring>(double angle)</argsstring>
        <name>eigenM3</name>
        <param>
          <type>double</type>
          <declname>angle</declname>
        </param>
        <briefdescription>
<para>returns the third axis DCM with the input angle </para>
        </briefdescription>
        <detaileddescription>
<para>This function returns the Eigen DCM that corresponds to a 3-axis rotation by the angle theta. The DCM is the positive theta rotation from the original frame to the final frame. <simplesect kind="return"><para>Eigen::Matrix3d </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>angle</parametername>
</parameternamelist>
<parameterdescription>
<para>The input rotation angle </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" line="214" column="17" bodyfile="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" bodystart="214" bodyend="226"/>
      </memberdef>
      <memberdef kind="function" id="avs_eigen_support_8cpp_1a1f80626a84c9644a9053ac510167e275" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Eigen::Matrix3d</type>
        <definition>Eigen::Matrix3d eigenTilde</definition>
        <argsstring>(Eigen::Vector3d vec)</argsstring>
        <name>eigenTilde</name>
        <param>
          <type>Eigen::Vector3d</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
<para>returns the tilde matrix representation of a vector (equivalent to a vector cross product) </para>
        </briefdescription>
        <detaileddescription>
<para>This function returns the tilde matrix version of a vector. The tilde matrix is the matrixi equivalent of a vector cross product, where [tilde_a] b == a x b <simplesect kind="return"><para>Eigen::Matrix3d </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vec</parametername>
</parameternamelist>
<parameterdescription>
<para>The input vector </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" line="234" column="17" bodyfile="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" bodystart="234" bodyend="248"/>
      </memberdef>
      <memberdef kind="function" id="avs_eigen_support_8cpp_1a49de110e503b1359b3949904518f8b2a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Eigen::MRPd</type>
        <definition>Eigen::MRPd eigenC2MRP</definition>
        <argsstring>(Eigen::Matrix3d dcm_Eigen)</argsstring>
        <name>eigenC2MRP</name>
        <param>
          <type>Eigen::Matrix3d</type>
          <declname>dcm_Eigen</declname>
        </param>
        <briefdescription>
<para>maps the DCM to MRPs using Eigen variables </para>
        </briefdescription>
        <detaileddescription>
<para>This function converts the Eigen DCM to an Eigen MRPd <simplesect kind="return"><para>Eigen::MRPd </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dcm_Eigen</parametername>
</parameternamelist>
<parameterdescription>
<para>The input DCM </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" line="254" column="13" bodyfile="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" bodystart="254" bodyend="265"/>
      </memberdef>
      <memberdef kind="function" id="avs_eigen_support_8cpp_1a3821688057605232aeca716cbcad7b67" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Eigen::Vector3d</type>
        <definition>Eigen::Vector3d eigenMRPd2Vector3d</definition>
        <argsstring>(Eigen::MRPd mrp)</argsstring>
        <name>eigenMRPd2Vector3d</name>
        <param>
          <type>Eigen::MRPd</type>
          <declname>mrp</declname>
        </param>
        <briefdescription>
<para>converts MRPd to an Vector3d variable </para>
        </briefdescription>
        <detaileddescription>
<para>This function converts the Eigen MRPd to Vector3d <simplesect kind="return"><para>Eigen::Vector3d </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mrp</parametername>
</parameternamelist>
<parameterdescription>
<para>The input Vector3d variable </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" line="271" column="17" bodyfile="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" bodystart="271" bodyend="280"/>
      </memberdef>
      <memberdef kind="function" id="avs_eigen_support_8cpp_1a1a03d3252025c2467082101aab67eedb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double newtonRaphsonSolve</definition>
        <argsstring>(const double &amp;initialEstimate, const double &amp;accuracy, const std::function&lt; double(double)&gt; &amp;f, const std::function&lt; double(double)&gt; &amp;fPrime)</argsstring>
        <name>newtonRaphsonSolve</name>
        <param>
          <type>const double &amp;</type>
          <declname>initialEstimate</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>accuracy</declname>
        </param>
        <param>
          <type>const std::function&lt; double(double)&gt; &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>const std::function&lt; double(double)&gt; &amp;</type>
          <declname>fPrime</declname>
        </param>
        <briefdescription>
<para>solves for the zero of the provided function </para>
        </briefdescription>
        <detaileddescription>
<para>This function solves for the zero of the passed function using the Newton Raphson Method <simplesect kind="return"><para>double </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>initialEstimate</parametername>
</parameternamelist>
<parameterdescription>
<para>The initial value to use for newton-raphson </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>accuracy</parametername>
</parameternamelist>
<parameterdescription>
<para>The desired upper bound for the error </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Function to find the zero of </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fPrime</parametername>
</parameternamelist>
<parameterdescription>
<para>First derivative of the function </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" line="289" column="8" bodyfile="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp" bodystart="289" bodyend="300"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">/*</highlight></codeline>
<codeline lineno="2"><highlight class="comment"><sp/>ISC<sp/>License</highlight></codeline>
<codeline lineno="3"><highlight class="comment"></highlight></codeline>
<codeline lineno="4"><highlight class="comment"><sp/>Copyright<sp/>(c)<sp/>2016,<sp/>Autonomous<sp/>Vehicle<sp/>Systems<sp/>Lab,<sp/>University<sp/>of<sp/>Colorado<sp/>at<sp/>Boulder</highlight></codeline>
<codeline lineno="5"><highlight class="comment"></highlight></codeline>
<codeline lineno="6"><highlight class="comment"><sp/>Permission<sp/>to<sp/>use,<sp/>copy,<sp/>modify,<sp/>and/or<sp/>distribute<sp/>this<sp/>software<sp/>for<sp/>any</highlight></codeline>
<codeline lineno="7"><highlight class="comment"><sp/>purpose<sp/>with<sp/>or<sp/>without<sp/>fee<sp/>is<sp/>hereby<sp/>granted,<sp/>provided<sp/>that<sp/>the<sp/>above</highlight></codeline>
<codeline lineno="8"><highlight class="comment"><sp/>copyright<sp/>notice<sp/>and<sp/>this<sp/>permission<sp/>notice<sp/>appear<sp/>in<sp/>all<sp/>copies.</highlight></codeline>
<codeline lineno="9"><highlight class="comment"></highlight></codeline>
<codeline lineno="10"><highlight class="comment"><sp/>THE<sp/>SOFTWARE<sp/>IS<sp/>PROVIDED<sp/>&quot;AS<sp/>IS&quot;<sp/>AND<sp/>THE<sp/>AUTHOR<sp/>DISCLAIMS<sp/>ALL<sp/>WARRANTIES</highlight></codeline>
<codeline lineno="11"><highlight class="comment"><sp/>WITH<sp/>REGARD<sp/>TO<sp/>THIS<sp/>SOFTWARE<sp/>INCLUDING<sp/>ALL<sp/>IMPLIED<sp/>WARRANTIES<sp/>OF</highlight></codeline>
<codeline lineno="12"><highlight class="comment"><sp/>MERCHANTABILITY<sp/>AND<sp/>FITNESS.<sp/>IN<sp/>NO<sp/>EVENT<sp/>SHALL<sp/>THE<sp/>AUTHOR<sp/>BE<sp/>LIABLE<sp/>FOR</highlight></codeline>
<codeline lineno="13"><highlight class="comment"><sp/>ANY<sp/>SPECIAL,<sp/>DIRECT,<sp/>INDIRECT,<sp/>OR<sp/>CONSEQUENTIAL<sp/>DAMAGES<sp/>OR<sp/>ANY<sp/>DAMAGES</highlight></codeline>
<codeline lineno="14"><highlight class="comment"><sp/>WHATSOEVER<sp/>RESULTING<sp/>FROM<sp/>LOSS<sp/>OF<sp/>USE,<sp/>DATA<sp/>OR<sp/>PROFITS,<sp/>WHETHER<sp/>IN<sp/>AN</highlight></codeline>
<codeline lineno="15"><highlight class="comment"><sp/>ACTION<sp/>OF<sp/>CONTRACT,<sp/>NEGLIGENCE<sp/>OR<sp/>OTHER<sp/>TORTIOUS<sp/>ACTION,<sp/>ARISING<sp/>OUT<sp/>OF</highlight></codeline>
<codeline lineno="16"><highlight class="comment"><sp/>OR<sp/>IN<sp/>CONNECTION<sp/>WITH<sp/>THE<sp/>USE<sp/>OR<sp/>PERFORMANCE<sp/>OF<sp/>THIS<sp/>SOFTWARE.</highlight></codeline>
<codeline lineno="17"><highlight class="comment"></highlight></codeline>
<codeline lineno="18"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="19"><highlight class="normal"></highlight></codeline>
<codeline lineno="20"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="21"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;math.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="22"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;avsEigenSupport.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="23"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;rigidBodyKinematics.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="24"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;architecture/utilities/macroDefinitions.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="25"><highlight class="normal"></highlight></codeline>
<codeline lineno="26"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="27"><highlight class="comment"></highlight></codeline>
<codeline lineno="28"><highlight class="comment"><sp/>Contains<sp/>various<sp/>support<sp/>algorithms<sp/>related<sp/>to<sp/>using<sp/>the<sp/>Eigen<sp/>Library</highlight></codeline>
<codeline lineno="29"><highlight class="comment"></highlight></codeline>
<codeline lineno="30"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="31"><highlight class="normal"></highlight></codeline>
<codeline lineno="40"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eigenMatrixXd2CArray(Eigen::MatrixXd<sp/>inMat,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*outArray)</highlight></codeline>
<codeline lineno="41"><highlight class="normal">{</highlight></codeline>
<codeline lineno="42"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::MatrixXd<sp/>tempMat<sp/>=<sp/>inMat.transpose();</highlight></codeline>
<codeline lineno="43"><highlight class="normal"><sp/><sp/><sp/><sp/>memcpy(outArray,<sp/>tempMat.data(),<sp/>inMat.rows()*inMat.cols()*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="44"><highlight class="normal">}</highlight></codeline>
<codeline lineno="45"><highlight class="normal"></highlight></codeline>
<codeline lineno="54"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eigenMatrixXi2CArray(Eigen::MatrixXi<sp/>inMat,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*outArray)</highlight></codeline>
<codeline lineno="55"><highlight class="normal">{</highlight></codeline>
<codeline lineno="56"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::MatrixXi<sp/>tempMat<sp/>=<sp/>inMat.transpose();</highlight></codeline>
<codeline lineno="57"><highlight class="normal"><sp/><sp/><sp/><sp/>memcpy(outArray,<sp/>tempMat.data(),<sp/>inMat.rows()*inMat.cols()*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="58"><highlight class="normal">}</highlight></codeline>
<codeline lineno="59"><highlight class="normal"></highlight></codeline>
<codeline lineno="67"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eigenVector3d2CArray(Eigen::Vector3d<sp/>&amp;<sp/>inMat,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*outArray)</highlight></codeline>
<codeline lineno="68"><highlight class="normal">{</highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/><sp/><sp/>memcpy(outArray,<sp/>inMat.data(),<sp/>3<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="70"><highlight class="normal">}</highlight></codeline>
<codeline lineno="71"><highlight class="normal"></highlight></codeline>
<codeline lineno="79"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eigenMRPd2CArray(Eigen::Vector3d&amp;<sp/>inMat,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>outArray)</highlight></codeline>
<codeline lineno="80"><highlight class="normal">{</highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><sp/><sp/>memcpy(outArray,<sp/>inMat.data(),<sp/>3<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="82"><highlight class="normal">}</highlight></codeline>
<codeline lineno="83"><highlight class="normal"></highlight></codeline>
<codeline lineno="91"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eigenMatrix3d2CArray(Eigen::Matrix3d<sp/>&amp;<sp/>inMat,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*outArray)</highlight></codeline>
<codeline lineno="92"><highlight class="normal">{</highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::MatrixXd<sp/>tempMat<sp/>=<sp/>inMat.transpose();</highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/><sp/><sp/>memcpy(outArray,<sp/>tempMat.data(),<sp/>9<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="95"><highlight class="normal">}</highlight></codeline>
<codeline lineno="96"><highlight class="normal"></highlight></codeline>
<codeline lineno="106"><highlight class="normal">Eigen::MatrixXd<sp/>cArray2EigenMatrixXd(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*inArray,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nRows,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nCols)</highlight></codeline>
<codeline lineno="107"><highlight class="normal">{</highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::MatrixXd<sp/>outMat;</highlight></codeline>
<codeline lineno="109"><highlight class="normal"><sp/><sp/><sp/><sp/>outMat.resize(nRows,<sp/>nCols);</highlight></codeline>
<codeline lineno="110"><highlight class="normal"><sp/><sp/><sp/><sp/>outMat<sp/>=<sp/>Eigen::Map&lt;Eigen::MatrixXd&gt;(inArray,<sp/>outMat.rows(),<sp/>outMat.cols());</highlight></codeline>
<codeline lineno="111"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>outMat;</highlight></codeline>
<codeline lineno="112"><highlight class="normal">}</highlight></codeline>
<codeline lineno="113"><highlight class="normal"></highlight></codeline>
<codeline lineno="120"><highlight class="normal">Eigen::Vector3d<sp/>cArray2EigenVector3d(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*inArray)</highlight></codeline>
<codeline lineno="121"><highlight class="normal">{</highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Eigen::Map&lt;Eigen::Vector3d&gt;(inArray,<sp/>3,<sp/>1);</highlight></codeline>
<codeline lineno="123"><highlight class="normal">}</highlight></codeline>
<codeline lineno="124"><highlight class="normal"></highlight></codeline>
<codeline lineno="131"><highlight class="normal">Eigen::MRPd<sp/>cArray2EigenMRPd(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>inArray)</highlight></codeline>
<codeline lineno="132"><highlight class="normal">{</highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::MRPd<sp/>sigma_Eigen;</highlight></codeline>
<codeline lineno="134"><highlight class="normal"><sp/><sp/><sp/><sp/>sigma_Eigen<sp/>=<sp/>cArray2EigenVector3d(inArray);</highlight></codeline>
<codeline lineno="135"><highlight class="normal"></highlight></codeline>
<codeline lineno="136"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>sigma_Eigen;</highlight></codeline>
<codeline lineno="137"><highlight class="normal">}</highlight></codeline>
<codeline lineno="138"><highlight class="normal"></highlight></codeline>
<codeline lineno="145"><highlight class="normal">Eigen::Matrix3d<sp/>cArray2EigenMatrix3d(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*inArray)</highlight></codeline>
<codeline lineno="146"><highlight class="normal">{</highlight></codeline>
<codeline lineno="147"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Eigen::Map&lt;Eigen::Matrix3d&gt;(inArray,<sp/>3,<sp/>3).transpose();</highlight></codeline>
<codeline lineno="148"><highlight class="normal">}</highlight></codeline>
<codeline lineno="149"><highlight class="normal"></highlight></codeline>
<codeline lineno="156"><highlight class="normal">Eigen::Matrix3d<sp/>c2DArray2EigenMatrix3d(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>in2DArray[3][3])</highlight></codeline>
<codeline lineno="157"><highlight class="normal">{</highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::Matrix3d<sp/>outMat;</highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>3;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>3;<sp/>j++)<sp/>{</highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outMat(i,<sp/>j)<sp/>=<sp/>in2DArray[i][j];</highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="163"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="164"><highlight class="normal"></highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>outMat;</highlight></codeline>
<codeline lineno="166"><highlight class="normal">}</highlight></codeline>
<codeline lineno="167"><highlight class="normal"></highlight></codeline>
<codeline lineno="174"><highlight class="normal">Eigen::Matrix3d<sp/>eigenM1(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>angle)</highlight></codeline>
<codeline lineno="175"><highlight class="normal">{</highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::Matrix3d<sp/>mOut;</highlight></codeline>
<codeline lineno="177"><highlight class="normal"></highlight></codeline>
<codeline lineno="178"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut.setIdentity();</highlight></codeline>
<codeline lineno="179"><highlight class="normal"></highlight></codeline>
<codeline lineno="180"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut(1,1)<sp/>=<sp/>cos(angle);</highlight></codeline>
<codeline lineno="181"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut(1,2)<sp/>=<sp/>sin(angle);</highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut(2,1)<sp/>=<sp/>-mOut(1,2);</highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut(2,2)<sp/>=<sp/>mOut(1,1);</highlight></codeline>
<codeline lineno="184"><highlight class="normal"></highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>mOut;</highlight></codeline>
<codeline lineno="186"><highlight class="normal">}</highlight></codeline>
<codeline lineno="187"><highlight class="normal"></highlight></codeline>
<codeline lineno="194"><highlight class="normal">Eigen::Matrix3d<sp/>eigenM2(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>angle)</highlight></codeline>
<codeline lineno="195"><highlight class="normal">{</highlight></codeline>
<codeline lineno="196"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::Matrix3d<sp/>mOut;</highlight></codeline>
<codeline lineno="197"><highlight class="normal"></highlight></codeline>
<codeline lineno="198"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut.setIdentity();</highlight></codeline>
<codeline lineno="199"><highlight class="normal"></highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut(0,0)<sp/>=<sp/>cos(angle);</highlight></codeline>
<codeline lineno="201"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut(0,2)<sp/>=<sp/>-sin(angle);</highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut(2,0)<sp/>=<sp/>-mOut(0,2);</highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut(2,2)<sp/>=<sp/>mOut(0,0);</highlight></codeline>
<codeline lineno="204"><highlight class="normal"></highlight></codeline>
<codeline lineno="205"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>mOut;</highlight></codeline>
<codeline lineno="206"><highlight class="normal">}</highlight></codeline>
<codeline lineno="207"><highlight class="normal"></highlight></codeline>
<codeline lineno="214"><highlight class="normal">Eigen::Matrix3d<sp/>eigenM3(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>angle)</highlight></codeline>
<codeline lineno="215"><highlight class="normal">{</highlight></codeline>
<codeline lineno="216"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::Matrix3d<sp/>mOut;</highlight></codeline>
<codeline lineno="217"><highlight class="normal"></highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut.setIdentity();</highlight></codeline>
<codeline lineno="219"><highlight class="normal"></highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut(0,0)<sp/>=<sp/>cos(angle);</highlight></codeline>
<codeline lineno="221"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut(0,1)<sp/>=<sp/>sin(angle);</highlight></codeline>
<codeline lineno="222"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut(1,0)<sp/>=<sp/>-mOut(0,1);</highlight></codeline>
<codeline lineno="223"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut(1,1)<sp/>=<sp/>mOut(0,0);</highlight></codeline>
<codeline lineno="224"><highlight class="normal"></highlight></codeline>
<codeline lineno="225"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>mOut;</highlight></codeline>
<codeline lineno="226"><highlight class="normal">}</highlight></codeline>
<codeline lineno="227"><highlight class="normal"></highlight></codeline>
<codeline lineno="234"><highlight class="normal">Eigen::Matrix3d<sp/>eigenTilde(Eigen::Vector3d<sp/>vec)</highlight></codeline>
<codeline lineno="235"><highlight class="normal">{</highlight></codeline>
<codeline lineno="236"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::Matrix3d<sp/>mOut;</highlight></codeline>
<codeline lineno="237"><highlight class="normal"></highlight></codeline>
<codeline lineno="238"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut(0,0)<sp/>=<sp/>mOut(1,1)<sp/>=<sp/>mOut(2,2)<sp/>=<sp/>0.0;</highlight></codeline>
<codeline lineno="239"><highlight class="normal"></highlight></codeline>
<codeline lineno="240"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut(0,1)<sp/>=<sp/>-vec(2);</highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut(1,0)<sp/>=<sp/><sp/>vec(2);</highlight></codeline>
<codeline lineno="242"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut(0,2)<sp/>=<sp/><sp/>vec(1);</highlight></codeline>
<codeline lineno="243"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut(2,0)<sp/>=<sp/>-vec(1);</highlight></codeline>
<codeline lineno="244"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut(1,2)<sp/>=<sp/>-vec(0);</highlight></codeline>
<codeline lineno="245"><highlight class="normal"><sp/><sp/><sp/><sp/>mOut(2,1)<sp/>=<sp/><sp/>vec(0);</highlight></codeline>
<codeline lineno="246"><highlight class="normal"></highlight></codeline>
<codeline lineno="247"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>mOut;</highlight></codeline>
<codeline lineno="248"><highlight class="normal">}</highlight></codeline>
<codeline lineno="249"><highlight class="normal"></highlight></codeline>
<codeline lineno="254"><highlight class="normal">Eigen::MRPd<sp/>eigenC2MRP(Eigen::Matrix3d<sp/>dcm_Eigen)</highlight></codeline>
<codeline lineno="255"><highlight class="normal">{</highlight></codeline>
<codeline lineno="256"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::MRPd<sp/>sigma_Eigen;<sp/><sp/></highlight><highlight class="comment">//<sp/>output<sp/>Eigen<sp/>MRP</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>dcm_Array[9];<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>C<sp/>array<sp/>DCM</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>sigma_Array[3];<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>C<sp/>array<sp/>MRP</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="259"><highlight class="normal"></highlight></codeline>
<codeline lineno="260"><highlight class="normal"><sp/><sp/><sp/><sp/>eigenMatrix3d2CArray(dcm_Eigen,<sp/>dcm_Array);</highlight></codeline>
<codeline lineno="261"><highlight class="normal"><sp/><sp/><sp/><sp/>C2MRP(RECAST3X3<sp/>dcm_Array,<sp/>sigma_Array);</highlight></codeline>
<codeline lineno="262"><highlight class="normal"><sp/><sp/><sp/><sp/>sigma_Eigen<sp/>=<sp/>cArray2EigenVector3d(sigma_Array);</highlight></codeline>
<codeline lineno="263"><highlight class="normal"></highlight></codeline>
<codeline lineno="264"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>sigma_Eigen;</highlight></codeline>
<codeline lineno="265"><highlight class="normal">}</highlight></codeline>
<codeline lineno="266"><highlight class="normal"></highlight></codeline>
<codeline lineno="271"><highlight class="normal">Eigen::Vector3d<sp/>eigenMRPd2Vector3d(Eigen::MRPd<sp/>mrp)</highlight></codeline>
<codeline lineno="272"><highlight class="normal">{</highlight></codeline>
<codeline lineno="273"><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::Vector3d<sp/>vec3d;</highlight></codeline>
<codeline lineno="274"><highlight class="normal"></highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/>vec3d[0]<sp/>=<sp/>mrp.x();</highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/><sp/><sp/>vec3d[1]<sp/>=<sp/>mrp.y();</highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/><sp/><sp/>vec3d[2]<sp/>=<sp/>mrp.z();</highlight></codeline>
<codeline lineno="278"><highlight class="normal"></highlight></codeline>
<codeline lineno="279"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>vec3d;</highlight></codeline>
<codeline lineno="280"><highlight class="normal">}</highlight></codeline>
<codeline lineno="281"><highlight class="normal"></highlight></codeline>
<codeline lineno="289"><highlight class="normal"></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>newtonRaphsonSolve(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">&amp;<sp/>initialEstimate,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">&amp;<sp/>accuracy,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::function&lt;</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">)&gt;&amp;<sp/>f,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::function&lt;</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">)&gt;&amp;<sp/>fPrime)<sp/>{</highlight></codeline>
<codeline lineno="290"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>currentEstimate<sp/>=<sp/>initialEstimate;</highlight></codeline>
<codeline lineno="291"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>100;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(std::abs(f(currentEstimate))<sp/>&lt;<sp/>accuracy)</highlight></codeline>
<codeline lineno="293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="294"><highlight class="normal"></highlight></codeline>
<codeline lineno="295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>functionVal<sp/>=<sp/>f(currentEstimate);</highlight></codeline>
<codeline lineno="296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>functionDeriv<sp/>=<sp/>fPrime(currentEstimate);</highlight></codeline>
<codeline lineno="297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currentEstimate<sp/>=<sp/>currentEstimate<sp/>-<sp/>functionVal/functionDeriv;</highlight></codeline>
<codeline lineno="298"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="299"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>currentEstimate;</highlight></codeline>
<codeline lineno="300"><highlight class="normal">}</highlight></codeline>
<codeline lineno="301"><highlight class="normal"></highlight></codeline>
    </programlisting>
    <location file="/Users/julio/Desktop/basilisk/src/architecture/utilities/avsEigenSupport.cpp"/>
  </compounddef>
</doxygen>
