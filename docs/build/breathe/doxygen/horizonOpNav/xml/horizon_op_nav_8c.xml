<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="horizon_op_nav_8c" kind="file" language="C++">
    <compoundname>horizonOpNav.c</compoundname>
    <includes local="no">math.h</includes>
    <includes local="no">string.h</includes>
    <includes local="no">stdlib.h</includes>
    <includes refid="horizon_op_nav_8h" local="yes">horizonOpNav.h</includes>
    <incdepgraph>
      <node id="1">
        <label>/Users/julio/Desktop/basilisk/src/fswAlgorithms/imageProcessing/horizonOpNav/horizonOpNav.c</label>
        <link refid="horizon_op_nav_8c"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
      </node>
      <node id="5">
        <label>horizonOpNav.h</label>
        <link refid="horizon_op_nav_8h_source"/>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
      </node>
      <node id="12">
        <label>architecture/utilities/astroConstants.h</label>
      </node>
      <node id="14">
        <label>architecture/utilities/bskLogging.h</label>
      </node>
      <node id="11">
        <label>architecture/utilities/linearAlgebra.h</label>
      </node>
      <node id="10">
        <label>architecture/utilities/macroDefinitions.h</label>
      </node>
      <node id="13">
        <label>architecture/utilities/rigidBodyKinematics.h</label>
      </node>
      <node id="8">
        <label>cMsgCInterface/CameraConfigMsg_C.h</label>
      </node>
      <node id="6">
        <label>cMsgCInterface/NavAttMsg_C.h</label>
      </node>
      <node id="7">
        <label>cMsgCInterface/OpNavLimbMsg_C.h</label>
      </node>
      <node id="9">
        <label>cMsgCInterface/OpNavMsg_C.h</label>
      </node>
      <node id="2">
        <label>math.h</label>
      </node>
      <node id="4">
        <label>stdlib.h</label>
      </node>
      <node id="3">
        <label>string.h</label>
      </node>
    </incdepgraph>
    <sectiondef kind="func">
      <memberdef kind="function" id="horizon_op_nav_8c_1abf8c5797f218b4f158e27b45bcf71ff5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SelfInit_horizonOpNav</definition>
        <argsstring>(HorizonOpNavData *configData, int64_t moduleID)</argsstring>
        <name>SelfInit_horizonOpNav</name>
        <param>
          <type><ref refid="struct_horizon_op_nav_data" kindref="compound">HorizonOpNavData</ref> *</type>
          <declname>configData</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>moduleID</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This method transforms pixel, line, and diameter data into heading data for orbit determination or heading determination. <simplesect kind="return"><para>void </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>configData</parametername>
</parameternamelist>
<parameterdescription>
<para>The configuration data associated with the ephemeris model </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>moduleID</parametername>
</parameternamelist>
<parameterdescription>
<para>The module identification integer </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/fswAlgorithms/imageProcessing/horizonOpNav/horizonOpNav.c" line="32" column="6" bodyfile="/Users/julio/Desktop/basilisk/src/fswAlgorithms/imageProcessing/horizonOpNav/horizonOpNav.c" bodystart="32" bodyend="35"/>
      </memberdef>
      <memberdef kind="function" id="horizon_op_nav_8c_1a3ae3e26109194709d9b5dd5a655312db" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Reset_horizonOpNav</definition>
        <argsstring>(HorizonOpNavData *configData, uint64_t callTime, int64_t moduleID)</argsstring>
        <name>Reset_horizonOpNav</name>
        <param>
          <type><ref refid="struct_horizon_op_nav_data" kindref="compound">HorizonOpNavData</ref> *</type>
          <declname>configData</declname>
        </param>
        <param>
          <type>uint64_t</type>
          <declname>callTime</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>moduleID</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This resets the module to original states. <simplesect kind="return"><para>void </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>configData</parametername>
</parameternamelist>
<parameterdescription>
<para>The configuration data associated with the ephemeris model </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callTime</parametername>
</parameternamelist>
<parameterdescription>
<para>The clock time at which the function was called (nanoseconds) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>moduleID</parametername>
</parameternamelist>
<parameterdescription>
<para>The module identification integer </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/fswAlgorithms/imageProcessing/horizonOpNav/horizonOpNav.c" line="44" column="6" bodyfile="/Users/julio/Desktop/basilisk/src/fswAlgorithms/imageProcessing/horizonOpNav/horizonOpNav.c" bodystart="44" bodyend="57"/>
      </memberdef>
      <memberdef kind="function" id="horizon_op_nav_8c_1a3bd8e8af3ed05fba2a5d077f480418b8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Update_horizonOpNav</definition>
        <argsstring>(HorizonOpNavData *configData, uint64_t callTime, int64_t moduleID)</argsstring>
        <name>Update_horizonOpNav</name>
        <param>
          <type><ref refid="struct_horizon_op_nav_data" kindref="compound">HorizonOpNavData</ref> *</type>
          <declname>configData</declname>
        </param>
        <param>
          <type>uint64_t</type>
          <declname>callTime</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>moduleID</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This method reads in the camera and circle messages and extracts navigation data from them. It outputs the heading (norm and direction) to the celestial body identified in the inertial frame. It provides the heading to the most robust circle identified by the image processing algorithm. <simplesect kind="return"><para>void </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>configData</parametername>
</parameternamelist>
<parameterdescription>
<para>The configuration data associated with the ephemeris model </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callTime</parametername>
</parameternamelist>
<parameterdescription>
<para>The clock time at which the function was called (nanoseconds) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>moduleID</parametername>
</parameternamelist>
<parameterdescription>
<para>The module identification integer </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
<para><itemizedlist>
<listitem><para>zero copies of output messages</para>
</listitem></itemizedlist>
</para>
<para><itemizedlist>
<listitem><para>read input messages</para>
</listitem></itemizedlist>
</para>
<para>Check the validity of the image</para>
<para>Create Q matrix, the square root inverse of the A matrix, eq (6) in Engineering Note</para>
<para>Build DCMs</para>
<para><itemizedlist>
<listitem><para>Find pixel size using camera specs</para>
</listitem></itemizedlist>
</para>
<para>Matrix of all the limb points</para>
<para>variables for covariance</para>
<para>Set the map from pixel to position eq (8) in Journal</para>
<para>Set the noise matrix in pix eq (53) in Engineering Note</para>
<para>Rotate R_s with B eq (52) in Journal</para>
<para>Create the H matrix. This is the stacked vector of all the limb points eq (33) in Engineering Note attached</para>
<para><itemizedlist>
<listitem><para>Put the pixel data in s (not s currently)</para>
</listitem></itemizedlist>
</para>
<para><itemizedlist>
<listitem><para>Apply the trasnformation computed previously from pixel to position</para>
</listitem></itemizedlist>
</para>
<para><itemizedlist>
<listitem><para>Rotate the Vector in the inertial frame</para>
</listitem></itemizedlist>
</para>
<para><itemizedlist>
<listitem><para>We now have s_bar in the Journal Paper, store to later compute J for uncertainty</para>
</listitem></itemizedlist>
</para>
<para>Need to solve Hn = 1, for n. If we performa QR decomp on H, the problem becomes: Rn = Q^T.1</para>
<para>Perform the QR decompostion of H, this will</para>
<para>Useful scalars for the rest of the implementation</para>
<para><itemizedlist>
<listitem><para>QR decomp</para>
</listitem></itemizedlist>
</para>
<para>Backsub to get n</para>
<para><itemizedlist>
<listitem><para>With all the s_bar terms, and n, we can compute J eq(50) in journal, and get uncertainty</para>
</listitem></itemizedlist>
</para>
<para><itemizedlist>
<listitem><para>Equation 31 in Journal</para>
</listitem></itemizedlist>
</para>
<para><itemizedlist>
<listitem><para>Rotate the Vector in the inertial frame</para>
</listitem></itemizedlist>
</para>
<para><itemizedlist>
<listitem><para>Covar from least squares - probably the most computationally expensive segment</para>
</listitem></itemizedlist>
</para>
<para><itemizedlist>
<listitem><para>Compute Scale factor now that n is computed</para>
</listitem></itemizedlist>
</para>
<para><itemizedlist>
<listitem><para>Build F from eq (55) of engineering note</para>
</listitem></itemizedlist>
</para>
<para><itemizedlist>
<listitem><para>Get the heading</para>
</listitem></itemizedlist>
</para>
<para><itemizedlist>
<listitem><para>Build F from eq (55) of engineering note</para>
</listitem></itemizedlist>
</para>
<para><itemizedlist>
<listitem><para>Get covar from eq (57) of engineering note</para>
</listitem></itemizedlist>
</para>
<para><itemizedlist>
<listitem><para>Transform to desireable frames</para>
</listitem></itemizedlist>
</para>
<para><itemizedlist>
<listitem><para>write output message</para>
</listitem></itemizedlist>
</para>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/fswAlgorithms/imageProcessing/horizonOpNav/horizonOpNav.c" line="65" column="6" bodyfile="/Users/julio/Desktop/basilisk/src/fswAlgorithms/imageProcessing/horizonOpNav/horizonOpNav.c" bodystart="65" bodyend="263"/>
      </memberdef>
      <memberdef kind="function" id="horizon_op_nav_8c_1ad09dc0ac0a8b0f2e6868f7ee8a1b9c3e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void QRDecomp</definition>
        <argsstring>(double *inMat, int32_t nRow, double *Q, double *R)</argsstring>
        <name>QRDecomp</name>
        <param>
          <type>double *</type>
          <declname>inMat</declname>
        </param>
        <param>
          <type>int32_t</type>
          <declname>nRow</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>Q</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>R</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This performs a QR decomposition on a input matrix. In this method it&apos;s used on the H matrix made up of the limb points <simplesect kind="return"><para>void </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>inMat</parametername>
</parameternamelist>
<parameterdescription>
<para>The input matrix to decompose </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nRow</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of rows </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Q</parametername>
</parameternamelist>
<parameterdescription>
<para>The output Q matrix (numbLimb x 3) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>R</parametername>
</parameternamelist>
<parameterdescription>
<para>The output R matrix (3 x 3) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/fswAlgorithms/imageProcessing/horizonOpNav/horizonOpNav.c" line="273" column="6" bodyfile="/Users/julio/Desktop/basilisk/src/fswAlgorithms/imageProcessing/horizonOpNav/horizonOpNav.c" bodystart="273" bodyend="308"/>
      </memberdef>
      <memberdef kind="function" id="horizon_op_nav_8c_1a81aa6c3aef0e7701d8bb8b0ddde62213" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void BackSub</definition>
        <argsstring>(double *R, double *inVec, int32_t nRow, double *n)</argsstring>
        <name>BackSub</name>
        <param>
          <type>double *</type>
          <declname>R</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>inVec</declname>
        </param>
        <param>
          <type>int32_t</type>
          <declname>nRow</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This performs a backsubstitution solve. This methods solves for n given Rn = V with R an upper triangular matrix. <simplesect kind="return"><para>void </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>R</parametername>
</parameternamelist>
<parameterdescription>
<para>The upper triangular matrix for the backsolve </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>inVec</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector on the Right-Hand-Side of the Rn = V equation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nRow</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of rows/columns </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>The solution vector </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/julio/Desktop/basilisk/src/fswAlgorithms/imageProcessing/horizonOpNav/horizonOpNav.c" line="317" column="6" bodyfile="/Users/julio/Desktop/basilisk/src/fswAlgorithms/imageProcessing/horizonOpNav/horizonOpNav.c" bodystart="317" bodyend="336"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">/*</highlight></codeline>
<codeline lineno="2"><highlight class="comment"><sp/>ISC<sp/>License</highlight></codeline>
<codeline lineno="3"><highlight class="comment"></highlight></codeline>
<codeline lineno="4"><highlight class="comment"><sp/>Copyright<sp/>(c)<sp/>2016,<sp/>Autonomous<sp/>Vehicle<sp/>Systems<sp/>Lab,<sp/>University<sp/>of<sp/>Colorado<sp/>at<sp/>Boulder</highlight></codeline>
<codeline lineno="5"><highlight class="comment"></highlight></codeline>
<codeline lineno="6"><highlight class="comment"><sp/>Permission<sp/>to<sp/>use,<sp/>copy,<sp/>modify,<sp/>and/or<sp/>distribute<sp/>this<sp/>software<sp/>for<sp/>any</highlight></codeline>
<codeline lineno="7"><highlight class="comment"><sp/>purpose<sp/>with<sp/>or<sp/>without<sp/>fee<sp/>is<sp/>hereby<sp/>granted,<sp/>provided<sp/>that<sp/>the<sp/>above</highlight></codeline>
<codeline lineno="8"><highlight class="comment"><sp/>copyright<sp/>notice<sp/>and<sp/>this<sp/>permission<sp/>notice<sp/>appear<sp/>in<sp/>all<sp/>copies.</highlight></codeline>
<codeline lineno="9"><highlight class="comment"></highlight></codeline>
<codeline lineno="10"><highlight class="comment"><sp/>THE<sp/>SOFTWARE<sp/>IS<sp/>PROVIDED<sp/>&quot;AS<sp/>IS&quot;<sp/>AND<sp/>THE<sp/>AUTHOR<sp/>DISCLAIMS<sp/>ALL<sp/>WARRANTIES</highlight></codeline>
<codeline lineno="11"><highlight class="comment"><sp/>WITH<sp/>REGARD<sp/>TO<sp/>THIS<sp/>SOFTWARE<sp/>INCLUDING<sp/>ALL<sp/>IMPLIED<sp/>WARRANTIES<sp/>OF</highlight></codeline>
<codeline lineno="12"><highlight class="comment"><sp/>MERCHANTABILITY<sp/>AND<sp/>FITNESS.<sp/>IN<sp/>NO<sp/>EVENT<sp/>SHALL<sp/>THE<sp/>AUTHOR<sp/>BE<sp/>LIABLE<sp/>FOR</highlight></codeline>
<codeline lineno="13"><highlight class="comment"><sp/>ANY<sp/>SPECIAL,<sp/>DIRECT,<sp/>INDIRECT,<sp/>OR<sp/>CONSEQUENTIAL<sp/>DAMAGES<sp/>OR<sp/>ANY<sp/>DAMAGES</highlight></codeline>
<codeline lineno="14"><highlight class="comment"><sp/>WHATSOEVER<sp/>RESULTING<sp/>FROM<sp/>LOSS<sp/>OF<sp/>USE,<sp/>DATA<sp/>OR<sp/>PROFITS,<sp/>WHETHER<sp/>IN<sp/>AN</highlight></codeline>
<codeline lineno="15"><highlight class="comment"><sp/>ACTION<sp/>OF<sp/>CONTRACT,<sp/>NEGLIGENCE<sp/>OR<sp/>OTHER<sp/>TORTIOUS<sp/>ACTION,<sp/>ARISING<sp/>OUT<sp/>OF</highlight></codeline>
<codeline lineno="16"><highlight class="comment"><sp/>OR<sp/>IN<sp/>CONNECTION<sp/>WITH<sp/>THE<sp/>USE<sp/>OR<sp/>PERFORMANCE<sp/>OF<sp/>THIS<sp/>SOFTWARE.</highlight></codeline>
<codeline lineno="17"><highlight class="comment"></highlight></codeline>
<codeline lineno="18"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="19"><highlight class="normal"></highlight></codeline>
<codeline lineno="20"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;math.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="21"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="22"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdlib.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="23"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;horizonOpNav.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="24"><highlight class="normal"></highlight></codeline>
<codeline lineno="25"><highlight class="normal"></highlight></codeline>
<codeline lineno="26"><highlight class="normal"></highlight></codeline>
<codeline lineno="32"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>SelfInit_horizonOpNav(<ref refid="struct_horizon_op_nav_data" kindref="compound">HorizonOpNavData</ref><sp/>*configData,<sp/>int64_t<sp/>moduleID)</highlight></codeline>
<codeline lineno="33"><highlight class="normal">{</highlight></codeline>
<codeline lineno="34"><highlight class="normal"><sp/><sp/><sp/><sp/>OpNavMsg_C_init(&amp;configData-&gt;<ref refid="struct_horizon_op_nav_data_1a000d3b2d092d56e46ca2e9bc5a1cc5a1" kindref="member">opNavOutMsg</ref>);</highlight></codeline>
<codeline lineno="35"><highlight class="normal">}</highlight></codeline>
<codeline lineno="36"><highlight class="normal"></highlight></codeline>
<codeline lineno="37"><highlight class="normal"></highlight></codeline>
<codeline lineno="44"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Reset_horizonOpNav(<ref refid="struct_horizon_op_nav_data" kindref="compound">HorizonOpNavData</ref><sp/>*configData,<sp/>uint64_t<sp/>callTime,<sp/>int64_t<sp/>moduleID)</highlight></codeline>
<codeline lineno="45"><highlight class="normal">{</highlight></codeline>
<codeline lineno="46"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>check<sp/>that<sp/>the<sp/>required<sp/>message<sp/>has<sp/>not<sp/>been<sp/>connected</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="47"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!CameraConfigMsg_C_isLinked(&amp;configData-&gt;<ref refid="struct_horizon_op_nav_data_1a3ff9caec8f762a7c95790b80aea9fb29" kindref="member">cameraConfigInMsg</ref>))<sp/>{</highlight></codeline>
<codeline lineno="48"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_bskLog(configData-&gt;<ref refid="struct_horizon_op_nav_data_1aedfbcd9a6b605d1caa2ec74086970f1a" kindref="member">bskLogger</ref>,<sp/>BSK_ERROR,<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>horizonOpNav.cameraConfigInMsg<sp/>wasn&apos;t<sp/>connected.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="49"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="50"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!OpNavLimbMsg_C_isLinked(&amp;configData-&gt;<ref refid="struct_horizon_op_nav_data_1a5c06eee2505924df39c41f724742a778" kindref="member">limbInMsg</ref>))<sp/>{</highlight></codeline>
<codeline lineno="51"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_bskLog(configData-&gt;<ref refid="struct_horizon_op_nav_data_1aedfbcd9a6b605d1caa2ec74086970f1a" kindref="member">bskLogger</ref>,<sp/>BSK_ERROR,<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>horizonOpNav.limbInMsg<sp/>wasn&apos;t<sp/>connected.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="52"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="53"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!NavAttMsg_C_isLinked(&amp;configData-&gt;<ref refid="struct_horizon_op_nav_data_1a904b619c8f2dfbf189d29aefd83fda71" kindref="member">attInMsg</ref>))<sp/>{</highlight></codeline>
<codeline lineno="54"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_bskLog(configData-&gt;<ref refid="struct_horizon_op_nav_data_1aedfbcd9a6b605d1caa2ec74086970f1a" kindref="member">bskLogger</ref>,<sp/>BSK_ERROR,<sp/></highlight><highlight class="stringliteral">&quot;Error:<sp/>horizonOpNav.attInMsg<sp/>wasn&apos;t<sp/>connected.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="55"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="56"><highlight class="normal"></highlight></codeline>
<codeline lineno="57"><highlight class="normal">}</highlight></codeline>
<codeline lineno="58"><highlight class="normal"></highlight></codeline>
<codeline lineno="65"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Update_horizonOpNav(<ref refid="struct_horizon_op_nav_data" kindref="compound">HorizonOpNavData</ref><sp/>*configData,<sp/>uint64_t<sp/>callTime,<sp/>int64_t<sp/>moduleID)</highlight></codeline>
<codeline lineno="66"><highlight class="normal">{</highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>dcm_NC[3][3],<sp/>dcm_CB[3][3],<sp/>dcm_BN[3][3],<sp/>Q[3][3],<sp/>B[3][3];</highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>planetRad_Eq,<sp/>planetRad_Pol;</highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>covar_In_C[3][3],<sp/>covar_In_B[3][3],<sp/>covar_In_N[3][3];</highlight></codeline>
<codeline lineno="70"><highlight class="normal"><sp/><sp/><sp/><sp/>CameraConfigMsgPayload<sp/>cameraSpecs;</highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/><sp/><sp/>OpNavLimbMsgPayload<sp/>limbIn;</highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/><sp/><sp/>OpNavMsgPayload<sp/>opNavMsgOut;</highlight></codeline>
<codeline lineno="73"><highlight class="normal"><sp/><sp/><sp/><sp/>NavAttMsgPayload<sp/>attInfo;</highlight></codeline>
<codeline lineno="74"><highlight class="normal"></highlight></codeline>
<codeline lineno="76"><highlight class="normal"><sp/><sp/><sp/><sp/>opNavMsgOut<sp/>=<sp/>OpNavMsg_C_zeroMsgPayload();</highlight></codeline>
<codeline lineno="77"><highlight class="normal"></highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/><sp/><sp/>cameraSpecs<sp/>=<sp/>CameraConfigMsg_C_read(&amp;configData-&gt;<ref refid="struct_horizon_op_nav_data_1a3ff9caec8f762a7c95790b80aea9fb29" kindref="member">cameraConfigInMsg</ref>);</highlight></codeline>
<codeline lineno="80"><highlight class="normal"><sp/><sp/><sp/><sp/>limbIn<sp/>=<sp/>OpNavLimbMsg_C_read(&amp;configData-&gt;<ref refid="struct_horizon_op_nav_data_1a5c06eee2505924df39c41f724742a778" kindref="member">limbInMsg</ref>);</highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><sp/><sp/>attInfo<sp/>=<sp/>NavAttMsg_C_read(&amp;configData-&gt;<ref refid="struct_horizon_op_nav_data_1a904b619c8f2dfbf189d29aefd83fda71" kindref="member">attInMsg</ref>);</highlight></codeline>
<codeline lineno="82"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="84"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(limbIn.valid<sp/>==<sp/>0){</highlight></codeline>
<codeline lineno="85"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>opNavMsgOut.valid<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>OpNavMsg_C_write(&amp;opNavMsgOut,<sp/>&amp;configData-&gt;<ref refid="struct_horizon_op_nav_data_1a000d3b2d092d56e46ca2e9bc5a1cc5a1" kindref="member">opNavOutMsg</ref>,<sp/>moduleID,<sp/>callTime);</highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(configData-&gt;<ref refid="struct_horizon_op_nav_data_1a2eb3cb41d746d7d676aae3c5716ee3b5" kindref="member">planetTarget</ref><sp/>==1){</highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>planetRad_Eq<sp/>=<sp/>REQ_EARTH*1E3;</highlight><highlight class="comment">//in<sp/>m</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="92"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>planetRad_Pol<sp/>=<sp/>RP_EARTH*1E3;</highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>opNavMsgOut.planetID<sp/>=<sp/>configData-&gt;<ref refid="struct_horizon_op_nav_data_1a2eb3cb41d746d7d676aae3c5716ee3b5" kindref="member">planetTarget</ref>;</highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="95"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(configData-&gt;<ref refid="struct_horizon_op_nav_data_1a2eb3cb41d746d7d676aae3c5716ee3b5" kindref="member">planetTarget</ref><sp/>==2){</highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>planetRad_Eq<sp/>=<sp/>REQ_MARS*1E3;</highlight><highlight class="comment">//in<sp/>m</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="97"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>planetRad_Pol<sp/>=<sp/>RP_MARS*1E3;</highlight></codeline>
<codeline lineno="98"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>opNavMsgOut.planetID<sp/>=<sp/>configData-&gt;<ref refid="struct_horizon_op_nav_data_1a2eb3cb41d746d7d676aae3c5716ee3b5" kindref="member">planetTarget</ref>;</highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="100"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(configData-&gt;<ref refid="struct_horizon_op_nav_data_1a2eb3cb41d746d7d676aae3c5716ee3b5" kindref="member">planetTarget</ref><sp/>==3){</highlight></codeline>
<codeline lineno="101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>planetRad_Eq<sp/>=<sp/>REQ_JUPITER*1E3;</highlight><highlight class="comment">//in<sp/>m</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>planetRad_Pol<sp/>=<sp/>planetRad_Eq;</highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>opNavMsgOut.planetID<sp/>=<sp/>configData-&gt;<ref refid="struct_horizon_op_nav_data_1a2eb3cb41d746d7d676aae3c5716ee3b5" kindref="member">planetTarget</ref>;</highlight></codeline>
<codeline lineno="104"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/><sp/><sp/>m33Set(1/planetRad_Eq,<sp/>0,<sp/>0,<sp/>0,<sp/>1/planetRad_Eq,<sp/>0,<sp/>0,<sp/>0,<sp/>1/planetRad_Eq,<sp/>Q);</highlight></codeline>
<codeline lineno="106"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Set<sp/>the<sp/>number<sp/>of<sp/>limb<sp/>points<sp/>for<sp/>ease<sp/>of<sp/>use*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/><sp/><sp/>int32_t<sp/>numPoints;</highlight></codeline>
<codeline lineno="109"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>sigma_pix;</highlight></codeline>
<codeline lineno="110"><highlight class="normal"><sp/><sp/><sp/><sp/>numPoints<sp/>=<sp/>limbIn.numLimbPoints;</highlight></codeline>
<codeline lineno="111"><highlight class="normal"><sp/><sp/><sp/><sp/>sigma_pix<sp/>=<sp/>configData-&gt;<ref refid="struct_horizon_op_nav_data_1a30ca6f7b609bc09bf4df3b9b0b34ab91" kindref="member">noiseSF</ref>*cameraSpecs.resolution[0]/(numPoints);</highlight></codeline>
<codeline lineno="112"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/>configData-&gt;<ref refid="struct_horizon_op_nav_data_1a2eb3cb41d746d7d676aae3c5716ee3b5" kindref="member">planetTarget</ref><sp/>=<sp/>(int32_t)<sp/>limbIn.planetIds;</highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/>MRP2C(cameraSpecs.sigma_CB,<sp/>dcm_CB);</highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/>MRP2C(attInfo.sigma_BN,<sp/>dcm_BN);</highlight></codeline>
<codeline lineno="117"><highlight class="normal"><sp/><sp/><sp/><sp/>m33MultM33(dcm_CB,<sp/>dcm_BN,<sp/>dcm_NC);</highlight></codeline>
<codeline lineno="118"><highlight class="normal"><sp/><sp/><sp/><sp/>m33Transpose(dcm_NC,<sp/>dcm_NC);</highlight></codeline>
<codeline lineno="119"><highlight class="normal"><sp/><sp/><sp/><sp/>m33MultM33(Q,<sp/>dcm_NC,<sp/>B);</highlight></codeline>
<codeline lineno="120"><highlight class="normal"></highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>d_x,<sp/>d_y,<sp/>u_p,<sp/>v_p,<sp/>tranf[3][3],<sp/>alpha;</highlight></codeline>
<codeline lineno="123"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>R_s[3][3],<sp/>s[3],<sp/>J[3];</highlight></codeline>
<codeline lineno="124"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*H,<sp/>*s_bar,<sp/>*R_yInv;</highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/><sp/><sp/>H<sp/>=<sp/>malloc(MAX_LIMB_PNTS*3*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">));<sp/></highlight></codeline>
<codeline lineno="127"><highlight class="normal"><sp/><sp/><sp/><sp/>s_bar<sp/>=<sp/>malloc(MAX_LIMB_PNTS*3*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">));<sp/></highlight></codeline>
<codeline lineno="128"><highlight class="normal"><sp/><sp/><sp/><sp/>R_yInv<sp/>=<sp/>malloc(MAX_LIMB_PNTS*MAX_LIMB_PNTS*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/><sp/><sp/>vSetZero(H,<sp/>MAX_LIMB_PNTS*3);</highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>To<sp/>do:<sp/>replace<sp/>alpha<sp/>by<sp/>a<sp/>skew<sp/>read<sp/>from<sp/>the<sp/>camera<sp/>message<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="132"><highlight class="normal"><sp/><sp/><sp/><sp/>alpha<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>pX,<sp/>pY;</highlight></codeline>
<codeline lineno="134"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>compute<sp/>sensorSize/focalLength<sp/>=<sp/>2*tan(FOV/2)<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="135"><highlight class="normal"><sp/><sp/><sp/><sp/>pX<sp/>=<sp/>2.*tan(cameraSpecs.fieldOfView*cameraSpecs.resolution[0]/cameraSpecs.resolution[1]/2.0);</highlight></codeline>
<codeline lineno="136"><highlight class="normal"><sp/><sp/><sp/><sp/>pY<sp/>=<sp/>2.*tan(cameraSpecs.fieldOfView/2.0);</highlight></codeline>
<codeline lineno="137"><highlight class="normal"><sp/><sp/><sp/><sp/>d_x<sp/>=<sp/>cameraSpecs.resolution[0]/pX;</highlight></codeline>
<codeline lineno="138"><highlight class="normal"><sp/><sp/><sp/><sp/>d_y<sp/>=<sp/>cameraSpecs.resolution[1]/pY;</highlight></codeline>
<codeline lineno="139"><highlight class="normal"><sp/><sp/><sp/><sp/>u_p<sp/>=<sp/>cameraSpecs.resolution[0]/2;</highlight></codeline>
<codeline lineno="140"><highlight class="normal"><sp/><sp/><sp/><sp/>v_p<sp/>=<sp/>cameraSpecs.resolution[1]/2;</highlight></codeline>
<codeline lineno="141"><highlight class="normal"><sp/><sp/><sp/><sp/>m33SetZero(tranf);</highlight></codeline>
<codeline lineno="143"><highlight class="normal"><sp/><sp/><sp/><sp/>m33Set(1/d_x,<sp/>-alpha/(d_x*d_y),<sp/>(alpha*v_p<sp/>-<sp/>d_y*u_p)/(d_x*d_y),<sp/>0,<sp/>1/d_y,<sp/>-v_p/d_y,<sp/>0,<sp/>0,<sp/>1,<sp/>tranf);</highlight></codeline>
<codeline lineno="144"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="146"><highlight class="normal"><sp/><sp/><sp/><sp/>m33Set((sigma_pix*sigma_pix)/(d_x*d_x),<sp/>0,<sp/>0,<sp/>0,<sp/>(sigma_pix*sigma_pix)/(d_x*d_x),<sp/>0,<sp/>0,<sp/>0,<sp/>0,<sp/>R_s);</highlight></codeline>
<codeline lineno="148"><highlight class="normal"><sp/><sp/><sp/><sp/>m33MultM33(B,<sp/>R_s,<sp/>R_s);</highlight></codeline>
<codeline lineno="149"><highlight class="normal"><sp/><sp/><sp/><sp/>m33MultM33t(R_s,<sp/>B,<sp/>R_s);</highlight></codeline>
<codeline lineno="150"><highlight class="normal"><sp/><sp/><sp/><sp/>mSetZero(R_yInv,<sp/>numPoints,<sp/>numPoints);</highlight></codeline>
<codeline lineno="151"><highlight class="normal"></highlight></codeline>
<codeline lineno="152"><highlight class="normal"></highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i=0;<sp/>i&lt;numPoints<sp/>&amp;&amp;<sp/>i&lt;MAX_LIMB_PNTS;i++){</highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>v3SetZero(s);</highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>s[0]<sp/>=<sp/>limbIn.limbPoints[2*i];</highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>s[1]<sp/>=<sp/>limbIn.limbPoints[2*i<sp/>+<sp/>1];</highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>s[2]<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m33MultV3(tranf,<sp/>s,<sp/>s);</highlight></codeline>
<codeline lineno="163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m33MultV3(B,<sp/>s,<sp/>s);</highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>v3Copy(s,<sp/>&amp;s_bar[3*i]);</highlight></codeline>
<codeline lineno="166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>v3Normalize(s,<sp/>s);</highlight></codeline>
<codeline lineno="167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>v3Copy(s,<sp/>&amp;H[i*3]);</highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="169"><highlight class="normal"></highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>R_decomp[3*3],<sp/>jTemp[3];</highlight></codeline>
<codeline lineno="174"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>RHS_vec[3],<sp/>n[3],<sp/>IminusOuter[3][3],<sp/>outer[3][3],<sp/>sNorm;</highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>scaleFactor,<sp/>nNorm2,<sp/>sbarPrime[3];<sp/></highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*Q_decomp,<sp/>*ones;</highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/><sp/><sp/>Q_decomp<sp/>=<sp/>malloc(MAX_LIMB_PNTS*3*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="178"><highlight class="normal"><sp/><sp/><sp/><sp/>ones<sp/>=<sp/>malloc(MAX_LIMB_PNTS*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="179"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="181"><highlight class="normal"><sp/><sp/><sp/><sp/>QRDecomp(H,<sp/>numPoints,<sp/>Q_decomp,<sp/>R_decomp);</highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/>v3SetZero(RHS_vec);</highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/>vSetOnes(ones,<sp/>numPoints);</highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/><sp/><sp/>mtMultV(Q_decomp,<sp/>numPoints,<sp/>3,<sp/>ones,<sp/>RHS_vec);</highlight></codeline>
<codeline lineno="186"><highlight class="normal"><sp/><sp/><sp/><sp/>BackSub(R_decomp,<sp/>RHS_vec,<sp/>3,<sp/>n);</highlight></codeline>
<codeline lineno="187"><highlight class="normal"></highlight></codeline>
<codeline lineno="189"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i=0;<sp/>i&lt;numPoints;i++){</highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>v3SetZero(J);</highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sNorm<sp/>=<sp/>v3Norm(&amp;s_bar[3*i]);</highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m33SetIdentity(IminusOuter);</highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>v3Normalize(&amp;s_bar[3*i],<sp/>sbarPrime);</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>v3OuterProduct(sbarPrime,<sp/>sbarPrime,<sp/>outer);</highlight></codeline>
<codeline lineno="196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m33Subtract(IminusOuter,<sp/>outer,<sp/>IminusOuter);</highlight></codeline>
<codeline lineno="198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>v3tMultM33(n,<sp/>IminusOuter,<sp/>J);</highlight></codeline>
<codeline lineno="199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>v3Scale(1/sNorm,<sp/>J,<sp/>J);</highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>v3tMultM33(J,<sp/>R_s,<sp/>jTemp);</highlight></codeline>
<codeline lineno="201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>R_yInv[numPoints*i+i]<sp/>=<sp/>1/v3Dot(jTemp,<sp/>J);</highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="205"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>Pn[3][3];</highlight></codeline>
<codeline lineno="206"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>F[3][3];</highlight></codeline>
<codeline lineno="207"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>Rtemp;</highlight></codeline>
<codeline lineno="208"><highlight class="normal"><sp/><sp/><sp/><sp/>Rtemp<sp/>=<sp/>malloc(MAX_LIMB_PNTS*3*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="209"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="210"><highlight class="normal"><sp/><sp/><sp/><sp/>m33SetIdentity(Pn);</highlight></codeline>
<codeline lineno="211"><highlight class="normal"><sp/><sp/><sp/><sp/>mMultM(R_yInv,<sp/>numPoints,<sp/>numPoints,<sp/>H,<sp/>numPoints,<sp/>3,<sp/>Rtemp);</highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/>mtMultM(H,<sp/>numPoints,<sp/>3,<sp/>Rtemp,<sp/>numPoints,<sp/>3,<sp/>Pn);</highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/><sp/><sp/>m33Inverse(Pn,<sp/>Pn);</highlight></codeline>
<codeline lineno="214"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="216"><highlight class="normal"><sp/><sp/><sp/><sp/>nNorm2<sp/>=<sp/>v3Dot(n,<sp/>n);</highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/>scaleFactor<sp/>=<sp/>-1./sqrt(nNorm2-1);</highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/>v3OuterProduct(n,<sp/>n,<sp/>outer);</highlight></codeline>
<codeline lineno="221"><highlight class="normal"><sp/><sp/><sp/><sp/>m33Scale(1/(nNorm2-1),<sp/>outer,<sp/>outer);</highlight></codeline>
<codeline lineno="222"><highlight class="normal"><sp/><sp/><sp/><sp/>m33SetIdentity(IminusOuter);</highlight></codeline>
<codeline lineno="223"><highlight class="normal"><sp/><sp/><sp/><sp/>m33Subtract(IminusOuter,<sp/>outer,<sp/>IminusOuter);</highlight></codeline>
<codeline lineno="224"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="226"><highlight class="normal"><sp/><sp/><sp/><sp/>m33Inverse(B,<sp/>B);</highlight></codeline>
<codeline lineno="227"><highlight class="normal"><sp/><sp/><sp/><sp/>m33MultV3(B,<sp/>n,<sp/>n);</highlight></codeline>
<codeline lineno="228"><highlight class="normal"><sp/><sp/><sp/><sp/>v3Scale(scaleFactor,<sp/>n,<sp/>opNavMsgOut.r_BN_C);</highlight></codeline>
<codeline lineno="229"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="231"><highlight class="normal"><sp/><sp/><sp/><sp/>m33MultM33t(B,<sp/>IminusOuter,<sp/>F);</highlight></codeline>
<codeline lineno="232"><highlight class="normal"><sp/><sp/><sp/><sp/>m33Scale(scaleFactor,<sp/>F,<sp/>F);</highlight></codeline>
<codeline lineno="234"><highlight class="normal"><sp/><sp/><sp/><sp/>m33MultM33(F,<sp/>Pn,<sp/>covar_In_C);</highlight></codeline>
<codeline lineno="235"><highlight class="normal"><sp/><sp/><sp/><sp/>m33MultM33t(covar_In_C,<sp/>F,<sp/>covar_In_C);</highlight></codeline>
<codeline lineno="236"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="238"><highlight class="normal"><sp/><sp/><sp/><sp/>m33MultV3(dcm_NC,<sp/>opNavMsgOut.r_BN_C,<sp/>opNavMsgOut.r_BN_N);</highlight></codeline>
<codeline lineno="239"><highlight class="normal"><sp/><sp/><sp/><sp/>m33MultV3(dcm_BN,<sp/>opNavMsgOut.r_BN_N,<sp/>opNavMsgOut.r_BN_B);</highlight></codeline>
<codeline lineno="240"><highlight class="normal"><sp/><sp/><sp/><sp/>m33MultM33(dcm_NC,<sp/>covar_In_C,<sp/>covar_In_N);</highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/><sp/><sp/>m33MultM33t(covar_In_N,<sp/>dcm_NC,<sp/>covar_In_N);</highlight></codeline>
<codeline lineno="242"><highlight class="normal"><sp/><sp/><sp/><sp/>m33MultM33(dcm_BN,<sp/>covar_In_N,<sp/>covar_In_B);</highlight></codeline>
<codeline lineno="243"><highlight class="normal"><sp/><sp/><sp/><sp/>m33MultM33t(covar_In_B,<sp/>dcm_BN,<sp/>covar_In_B);</highlight></codeline>
<codeline lineno="244"><highlight class="normal"></highlight></codeline>
<codeline lineno="245"><highlight class="normal"></highlight></codeline>
<codeline lineno="247"><highlight class="normal"><sp/><sp/><sp/><sp/>mCopy(covar_In_N,<sp/>3,<sp/>3,<sp/>opNavMsgOut.covar_N);</highlight></codeline>
<codeline lineno="248"><highlight class="normal"><sp/><sp/><sp/><sp/>mCopy(covar_In_C,<sp/>3,<sp/>3,<sp/>opNavMsgOut.covar_C);</highlight></codeline>
<codeline lineno="249"><highlight class="normal"><sp/><sp/><sp/><sp/>mCopy(covar_In_B,<sp/>3,<sp/>3,<sp/>opNavMsgOut.covar_B);</highlight></codeline>
<codeline lineno="250"><highlight class="normal"><sp/><sp/><sp/><sp/>opNavMsgOut.timeTag<sp/>=<sp/>limbIn.timeTag;</highlight></codeline>
<codeline lineno="251"><highlight class="normal"><sp/><sp/><sp/><sp/>opNavMsgOut.valid<sp/>=1;</highlight></codeline>
<codeline lineno="252"><highlight class="normal"><sp/><sp/><sp/><sp/>OpNavMsg_C_write(&amp;opNavMsgOut,<sp/>&amp;configData-&gt;<ref refid="struct_horizon_op_nav_data_1a000d3b2d092d56e46ca2e9bc5a1cc5a1" kindref="member">opNavOutMsg</ref>,<sp/>moduleID,<sp/>callTime);</highlight></codeline>
<codeline lineno="253"><highlight class="normal"></highlight></codeline>
<codeline lineno="254"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>free<sp/>allocated<sp/>memory<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="255"><highlight class="normal"><sp/><sp/><sp/><sp/>free(H);</highlight></codeline>
<codeline lineno="256"><highlight class="normal"><sp/><sp/><sp/><sp/>free(s_bar);</highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/><sp/><sp/>free(R_yInv);</highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/><sp/><sp/>free(Rtemp);</highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/><sp/><sp/>free(ones);</highlight></codeline>
<codeline lineno="260"><highlight class="normal"><sp/><sp/><sp/><sp/>free(Q_decomp);</highlight></codeline>
<codeline lineno="261"><highlight class="normal"></highlight></codeline>
<codeline lineno="262"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="263"><highlight class="normal">}</highlight></codeline>
<codeline lineno="264"><highlight class="normal"></highlight></codeline>
<codeline lineno="265"><highlight class="normal"></highlight></codeline>
<codeline lineno="273"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>QRDecomp(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*inMat,<sp/>int32_t<sp/>nRow,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*Q<sp/>,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*R)</highlight></codeline>
<codeline lineno="274"><highlight class="normal">{</highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/>int32_t<sp/>i,<sp/>j;</highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*sourceMatT,<sp/>*QT;</highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>proj;</highlight></codeline>
<codeline lineno="278"><highlight class="normal"><sp/><sp/><sp/><sp/>proj<sp/>=<sp/>malloc(nRow*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="279"><highlight class="normal"><sp/><sp/><sp/><sp/>sourceMatT<sp/>=<sp/>malloc(MAX_LIMB_PNTS*3*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="280"><highlight class="normal"><sp/><sp/><sp/><sp/>QT<sp/>=<sp/>malloc(MAX_LIMB_PNTS*3*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="281"><highlight class="normal"></highlight></codeline>
<codeline lineno="282"><highlight class="normal"><sp/><sp/><sp/><sp/>mSetZero(Q,<sp/>nRow,<sp/>3);</highlight></codeline>
<codeline lineno="283"><highlight class="normal"><sp/><sp/><sp/><sp/>mSetZero(sourceMatT,<sp/>3,<sp/>MAX_LIMB_PNTS);</highlight></codeline>
<codeline lineno="284"><highlight class="normal"><sp/><sp/><sp/><sp/>mSetZero(QT,<sp/>3,<sp/>MAX_LIMB_PNTS);</highlight></codeline>
<codeline lineno="285"><highlight class="normal"><sp/><sp/><sp/><sp/>mSetZero(R,<sp/>3,<sp/>3);</highlight></codeline>
<codeline lineno="286"><highlight class="normal"><sp/><sp/><sp/><sp/>mTranspose(inMat,<sp/>nRow,<sp/>3,<sp/>sourceMatT);</highlight></codeline>
<codeline lineno="287"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="288"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i&lt;3;<sp/>i++){</highlight></codeline>
<codeline lineno="289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vSetZero(proj,<sp/>nRow);</highlight></codeline>
<codeline lineno="290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vCopy(&amp;sourceMatT[i*nRow],<sp/>nRow,<sp/>&amp;QT[i*nRow]);</highlight></codeline>
<codeline lineno="291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(j<sp/>=<sp/>0;<sp/>j&lt;i;<sp/>j++)</highlight></codeline>
<codeline lineno="292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>R[j*3+i]<sp/>=<sp/>vDot(&amp;QT[i*nRow],<sp/>nRow,<sp/>&amp;QT[j*nRow]);</highlight></codeline>
<codeline lineno="294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vScale(-R[j*3+i],<sp/>&amp;QT[j*nRow],<sp/>nRow,<sp/>proj);</highlight></codeline>
<codeline lineno="295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vAdd(&amp;QT[i*nRow],<sp/>nRow,<sp/>proj,<sp/>&amp;QT[i*nRow]);</highlight></codeline>
<codeline lineno="296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>R[i*3+i]<sp/>=<sp/>vNorm(&amp;QT[i*nRow],<sp/>nRow);</highlight></codeline>
<codeline lineno="298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vScale(1/R[i*3+i],<sp/>&amp;QT[i*nRow],<sp/>nRow,<sp/><sp/>&amp;QT[i*nRow]);</highlight></codeline>
<codeline lineno="299"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="300"><highlight class="normal"><sp/><sp/><sp/><sp/>mTranspose(QT,<sp/>3,<sp/>nRow,<sp/>Q);</highlight></codeline>
<codeline lineno="301"><highlight class="normal"></highlight></codeline>
<codeline lineno="302"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>free<sp/>allocated<sp/>memory<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="303"><highlight class="normal"><sp/><sp/><sp/><sp/>free(proj);</highlight></codeline>
<codeline lineno="304"><highlight class="normal"><sp/><sp/><sp/><sp/>free(sourceMatT);</highlight></codeline>
<codeline lineno="305"><highlight class="normal"><sp/><sp/><sp/><sp/>free(QT);</highlight></codeline>
<codeline lineno="306"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="307"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="308"><highlight class="normal">}</highlight></codeline>
<codeline lineno="309"><highlight class="normal"></highlight></codeline>
<codeline lineno="317"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>BackSub(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*R,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*inVec,<sp/>int32_t<sp/>nRow,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*n)</highlight></codeline>
<codeline lineno="318"><highlight class="normal">{</highlight></codeline>
<codeline lineno="319"><highlight class="normal"><sp/><sp/><sp/><sp/>int32_t<sp/>i,<sp/>j;</highlight></codeline>
<codeline lineno="320"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>sum;</highlight></codeline>
<codeline lineno="321"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="322"><highlight class="normal"><sp/><sp/><sp/><sp/>vSetZero(n,<sp/>nRow);</highlight></codeline>
<codeline lineno="323"><highlight class="normal"><sp/><sp/><sp/><sp/>n[nRow-1]<sp/>=<sp/>inVec[nRow-1]/R[nRow*nRow-1];</highlight></codeline>
<codeline lineno="324"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>nRow-2;<sp/>i&gt;=0;<sp/>i--)</highlight></codeline>
<codeline lineno="325"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sum<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(j<sp/>=<sp/>i<sp/>+<sp/>1;<sp/>j&lt;nRow;<sp/>j++)</highlight></codeline>
<codeline lineno="328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sum<sp/>+=<sp/>R[i*nRow<sp/>+<sp/>j]<sp/>*<sp/>n[j];</highlight></codeline>
<codeline lineno="330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n[i]<sp/>=<sp/>(inVec[i]<sp/>-sum)/R[i*nRow<sp/>+<sp/>i];</highlight></codeline>
<codeline lineno="333"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="334"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="335"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="336"><highlight class="normal">}</highlight></codeline>
<codeline lineno="337"><highlight class="normal"></highlight></codeline>
    </programlisting>
    <location file="/Users/julio/Desktop/basilisk/src/fswAlgorithms/imageProcessing/horizonOpNav/horizonOpNav.c"/>
  </compounddef>
</doxygen>
